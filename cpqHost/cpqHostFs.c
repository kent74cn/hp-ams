/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.container.conf,v 1.8 2006/07/26 15:58:26 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <net-snmp/agent/table_container.h>
#include <net-snmp/agent/cache_handler.h>
#include <net-snmp/agent/hardware/fsys.h>

#include <signal.h>

#include "cpqHostFs.h"

void init_hw_fsys(void);
void initialize_table_cpqHoFileSysTable(void);
Netsnmp_Node_Handler cpqHoFileSysTable_handler;

#if NETSNMPVERSMINOR == 7
#define get_fsys_cache netsnmp_fsys_get_cache
#define get_fsys_container netsnmp_fsys_get_container
#endif
netsnmp_cache *get_fsys_cache( void );
netsnmp_container *get_fsys_container( void );


/** Initializes the cpqHoFileSysrSWRunTable module */
void
init_cpqHoFileSysTable(void)
{
    /*
     * here we initialize all the tables we're planning on supporting
     */
    init_hw_fsys();

    initialize_table_cpqHoFileSysTable();
}

oid      cpqHoFileSysTable_oid[] = { 1, 3, 6, 1, 4, 1, 232, 11, 2, 4, 1 };
size_t   cpqHoFileSysTable_oid_len = OID_LENGTH(cpqHoFileSysTable_oid);

/** Initialize the cpqHoFileSysTable table by defining its contents and how it's structured */
void
initialize_table_cpqHoFileSysTable(void)
{
    netsnmp_handler_registration *reg;
    netsnmp_mib_handler *handler = NULL;
    netsnmp_table_registration_info *table_info = NULL;

    int reg_tbl_ret = SNMPERR_SUCCESS;

    reg =
        netsnmp_create_handler_registration(MYTABLE,
                                            cpqHoFileSysTable_handler,
                                            cpqHoFileSysTable_oid,
                                            cpqHoFileSysTable_oid_len,
                                            HANDLER_CAN_RONLY);
    if (NULL == reg) {
        snmp_log(LOG_ERR,"error creating handler registration for "
                 MYTABLE "\n");
        goto bail;
    }
    reg->modes |= HANDLER_CAN_NOT_CREATE;

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    if (NULL == table_info) {
        snmp_log(LOG_ERR,"error allocating table registration for "
                 MYTABLE "\n");
        goto bail;
    }

    /* index: cpqHoFileSysIndex */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   
                                     0);
    table_info->min_column = CPQHO_FILESYS_INDEX;
    table_info->max_column = CPQHO_FILESYS_STATUS;

    /*************************************************
    *
    * inject container_table helper
    */
    handler = 
        netsnmp_container_table_handler_get(table_info, 
                                            get_fsys_container(),
                                            TABLE_CONTAINER_KEY_NETSNMP_INDEX);
    if (NULL == handler) {
        snmp_log(LOG_ERR,"error allocating table registration for "
                 MYTABLE "\n");
        goto bail;
    }
    if (SNMPERR_SUCCESS != netsnmp_inject_handler(reg, handler)) {
        snmp_log(LOG_ERR,"error injecting container_table handler for "
                 MYTABLE "\n");
        goto bail;
    }
    handler = NULL; /* reg has it, will reuse below */

    /*************************************************
    *
    * inject cache helper
    * use existing  host resources mib 1.3.6.1.2.1.25.3.8
    */
    handler = netsnmp_cache_handler_get(get_fsys_cache());
    if (NULL == handler) {
        snmp_log(LOG_ERR, "error creating cache handler for " MYTABLE "\n");
        goto bail;
    }

    if (SNMPERR_SUCCESS != netsnmp_inject_handler(reg, handler)) {
        snmp_log(LOG_ERR,"error injecting cache handler for "
                 MYTABLE "\n");
        goto bail;
    }
    handler = NULL; /* reg has it*/

    reg_tbl_ret = netsnmp_register_table(reg, table_info);
    if (reg_tbl_ret != SNMPERR_SUCCESS) {
        snmp_log(LOG_ERR,"error registering table handler for "
                 MYTABLE "\n");
        goto bail;
    }

    return; /* ok */


  bail: /* not ok */

    if (handler)
        netsnmp_handler_free(handler);

    if (table_info)
        netsnmp_table_registration_info_free(table_info);

    if (reg_tbl_ret == SNMPERR_SUCCESS)
        if (reg)
            netsnmp_handler_registration_free(reg);

}

/** handles requests for the cpaHoFileSysTable table */
int
cpqHoFileSysTable_handler(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_fsys_info *table_entry;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            if (request->processed)
               continue;
            table_entry = (netsnmp_fsys_info *)
                netsnmp_container_table_extract_context(request);
            table_info = netsnmp_extract_table_info(request);
            if ((NULL == table_entry) || (NULL == table_info)) {
                snmp_log(LOG_ERR, "could not extract table entry or info for "
                 MYTABLE "\n");
                snmp_set_var_typed_value(request->requestvb,
                                         SNMP_ERR_GENERR, NULL, 0);
                continue;
            }

            switch (table_info->colnum) {
            case CPQHO_FILESYS_INDEX:
            {
                int item = 0;
                int len = 0;
                len = table_entry->idx.len;
                item = table_entry->idx.oids[len-1];
                
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           item);
            }
                break;
            case CPQHO_FILESYS_DESC:
                {
                    char description[256];
                    int count;
                    memset(description, 0, 256);
                    count = snprintf(description,255,"%s on %s",
                            table_entry->path, table_entry->device);
                    snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                         (u_char *)description, count);
                }
                break;
            case CPQHO_FILESYS_SPACETOTAL:
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                          table_entry->size);
                break;
            case CPQHO_FILESYS_SPACEUSED:
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                          table_entry->used);
                break;
            case CPQHO_FILESYS_PERCENTSPACEUSED:
                {
                    int percent = 0;
                    if (table_entry->size != 0) 
                        percent = (table_entry->size -  table_entry->avail)* 100/
                                    table_entry->size + .5; 
                    snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                        percent);
                }
                break;
            case CPQHO_FILESYS_ALLOCUNITSTOTAL:
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->inums_total);
                break;
            case CPQHO_FILESYS_ALLOCUNITSUSED:
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->inums_total -
                                           table_entry->inums_avail);
                break;
            case CPQHO_FILESYS_STATUS:
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           MIB_STATE_OK);

            default:
                /*
                 * An unsupported/unreadable column (if applicable)
                 */
                snmp_set_var_typed_value(request->requestvb,
                                         SNMP_NOSUCHOBJECT, NULL, 0);
            }
        }
        break;
    }
    return SNMP_ERR_NOERROR;
}


