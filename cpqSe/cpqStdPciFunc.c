/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <net-snmp/agent/cache_handler.h>

#include "data_access/cpqsepci.h"
#include "cpqStdPciFunc.h"

/**---------------------------------------------------------------------*/
/*
 * external per-architecture functions prototypes
 *
 * These shouldn't be called by the general public, so they aren't in
 * the header file.
 */
extern void netsnmp_arch_pcifunc_init(void);
extern int netsnmp_arch_pcifunc_container_load(netsnmp_container* container);
static void     _cache_free(netsnmp_cache * cache, void *magic);
static int      _cache_load(netsnmp_cache * cache, void *vmagic);

/*
 * cpqStdEquipment_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid cpqSePciFuncTable_oid[] = { 1, 3, 6, 1, 4, 1, 232, 1, 2, 13, 2};
size_t   cpqSePciFuncTable_oid_len = OID_LENGTH(cpqSePciFuncTable_oid);

void
    initialize_table_cpqSePciFuncTable(void)
{
    netsnmp_handler_registration *reg;
    netsnmp_mib_handler *handler = NULL;
    netsnmp_container *container = NULL;
    netsnmp_table_registration_info *table_info = NULL;
    netsnmp_cache  *cache = NULL;

    reg =
        netsnmp_create_handler_registration("cpqSePciFuncTable",
                                            cpqSePciFuncTable_handler,
                                            cpqSePciFuncTable_oid,
                                            cpqSePciFuncTable_oid_len,
                                            HANDLER_CAN_RONLY);

    if (NULL == reg) {
        snmp_log(LOG_ERR,"error creating handler registration for "
                 "cpqSePciFuncTable\n");
        goto bail;
    }
    reg->modes |= HANDLER_CAN_NOT_CREATE;

    container = netsnmp_container_find("cpqSePciFuncTable:table_container");
    if (NULL == container) {
        snmp_log(LOG_ERR, "error creating container for cpqSePciFuncTable\n");
        goto bail;
    }

    container->container_name = strdup("PciFuncTable container");

    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    if (NULL == table_info) {
        snmp_log(LOG_ERR,"error allocating table registration for "
                 "cpqSePciFuncTable\n");
        goto bail;
    }

    netsnmp_table_helper_add_indexes(table_info, 
                                     ASN_INTEGER,
                                     ASN_INTEGER,
                                     ASN_INTEGER,
                                     0);
    table_info->min_column = CPQSEPCIBUSNUMBERINDEX;
    table_info->max_column = CPQSEPCIFUNCDEVSTATUS;

    /*************************************************
     *
     * inject container_table helper
     */
    handler = netsnmp_container_table_handler_get(table_info, container,
                                            TABLE_CONTAINER_KEY_NETSNMP_INDEX);
    if (NULL == handler) {
        snmp_log(LOG_ERR,"error allocating table registration for "
                 "cpqSePciFuncTable\n");
        goto bail;
    }
    if (SNMPERR_SUCCESS != netsnmp_inject_handler(reg, handler)) {
        snmp_log(LOG_ERR,"error injecting container_table handler for "
                 "cpqSePciFuncTable\n");
        goto bail;
    }
    handler = NULL; /* reg has it, will reuse below */

    /*************************************************
     *
     * inject cache helper
     */
   cache = netsnmp_cache_create(240,    /* timeout in seconds */
                                 _cache_load, _cache_free,
                                 cpqSePciFuncTable_oid,
                                 cpqSePciFuncTable_oid_len); 

    if (NULL == cache) {
        snmp_log(LOG_ERR, "error creating cache for cpqSePciFuncTable\n");
        goto bail;
    }
    cache->flags = NETSNMP_CACHE_DONT_INVALIDATE_ON_SET;
    cache->magic = container;

    handler = netsnmp_cache_handler_get(cache);
    if (NULL == handler) {
        snmp_log(LOG_ERR, "error creating cache handler for cpqSePciFuncTable\n");
        goto bail;
    }

    if (SNMPERR_SUCCESS != netsnmp_inject_handler(reg, handler)) {
        snmp_log(LOG_ERR,"error injecting cache handler for "
                 "cpqSePciFuncTable\n");
        goto bail;
    }
    handler = NULL; /* reg has it*/

    if (SNMPERR_SUCCESS != netsnmp_register_table(reg, table_info)) {
        snmp_log(LOG_ERR,"error registering table handler for "
                 "cpqSePciFuncTable\n");
        goto bail;
    }

    netsnmp_arch_pcifunc_init();
    return; /* ok */


  bail: /* not ok */

    if (handler)
        netsnmp_handler_free(handler);

    if (cache)
        netsnmp_cache_free(cache);

    if (table_info)
        netsnmp_table_registration_info_free(table_info);

    if (container)
        CONTAINER_FREE(container);

    if (reg)
        netsnmp_handler_registration_free(reg);

}

/** create a new row in the table */
netsnmp_pcifunc_entry *
cpqSePciFuncTable_createEntry(netsnmp_container * container,
                              oid index, oid index2, oid index3)
{
    netsnmp_pcifunc_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(netsnmp_pcifunc_entry);
    if (!entry)
        return NULL;

    memset(entry, 0, sizeof(netsnmp_pcifunc_entry));
    entry->bus  = index;
    entry->dev  = index2;
    entry->func = index3;

    entry->oid_index.len = 3;
    entry->oid_index.oids = (oid *) & entry->bus;
    return entry;
}

#ifdef NOT_NEEDED
/** remove a row from the table */
void
cpqSePciFuncTable_removeEntry(netsnmp_container * container,
                         netsnmp_pcifunc_entry * entry)
{

    if (!entry)
        return;                 /* Nothing to remove */
    CONTAINER_REMOVE(container, entry);
    if (entry)
        SNMP_FREE(entry);       /* XXX - release any other internal resources */
}
#endif

/** remove a row from the table */
void
cpqSePciFuncTable_freeEntry(netsnmp_pcifunc_entry* entry)
{

    if (!entry)
        return;                 /* Nothing to remove */
    SNMP_FREE(entry);           /* XXX - release any other internal resources */
}

/** handles requests for the hrSWRunTable table */
int
cpqSePciFuncTable_handler(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_pcifunc_entry *table_entry;

    switch (reqinfo->mode) {
        /*
 *          * Read-support (also covers GetNext requests)
 *                   */
    case MODE_GET:
        for (request = requests; request; request = request->next) {
            if (request->processed)
               continue;
            table_entry = (netsnmp_pcifunc_entry *)
                netsnmp_container_table_extract_context(request);
            table_info = netsnmp_extract_table_info(request);
            if ((NULL == table_entry) || (NULL == table_info)) {
                snmp_log(LOG_ERR, "could not extract table entry or info for "
                 "cpqSePciFuncTable\n");
                snmp_set_var_typed_value(request->requestvb,
                                         SNMP_ERR_GENERR, NULL, 0);
                continue;
            }

            switch (table_info->colnum) {
            case CPQSEPCIBUSNUMBERINDEX:
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->bus);
                break;
            case CPQSEPCIFUNCTDEVICENUMBERINDEX:
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->dev);
                break;
            case CPQSEPCIFUNCINDEX:
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->func);
                break;
            case CPQSEPCIFUNCCLASSCODE:
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                   (u_char *) table_entry->class_code,
                                    PCIFUNC_CLASSC_SZ);
                break;
            case CPQSEPCIFUNCCLASSDESCRIPTION:
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                   (u_char *) table_entry->class_desc,
                                    strlen(table_entry->class_desc));
                break;
            case CPQSEPCIFUNCDEVICEID:
                if (table_entry->dev_status ==  PCI_DEVICE_ENABLED )
                    snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->device_id);
                else
                    snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           0);
                break;
            case CPQSEPCIFUNCVENDORID:
                if (table_entry->dev_status ==  PCI_DEVICE_ENABLED )
                    snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->vendor_id);
                else
                    snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           0);

                break;
            case CPQSEPCIFUNCREVID:
                if (table_entry->dev_status ==  PCI_DEVICE_ENABLED )
                    snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->rev_id);
                else
                    snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           0);

                break;
            case CPQSEPCIFUNCINTLINE:
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->int_line);
                break;
            case CPQSEPCIFUNCDEVSTATUS:
                snmp_set_var_typed_integer(request->requestvb, ASN_INTEGER,
                                           table_entry->dev_status);
                break;
            default:
                /*
                 * An unsupported/unreadable column (if applicable)
                 */
                snmp_set_var_typed_value(request->requestvb,
                                         SNMP_NOSUCHOBJECT, NULL, 0);
            }
        }
        break;
    }
    return SNMP_ERR_NOERROR;
}


/**
 * load pcifunc information in specified container
 *
 * @param container empty container to be filled.
 *                  pass NULL to have the function create one.
 *
 * @retval NULL  error
 * @retval !NULL pointer to container
 */
netsnmp_container*
netsnmp_pcifunc_container_load(netsnmp_container* user_container)
{
    netsnmp_container* container = user_container;
    int rc;

    DEBUGMSGTL(("pcifunc:container:load", "load\n"));

    if (NULL == container) {
        snmp_log(LOG_ERR, "no container specified/found for pcifunc\n");
        return NULL;
    }
    
    rc =  netsnmp_arch_pcifunc_container_load(container);
    if (0 != rc) {
        if (NULL == user_container) {
            CONTAINER_FREE(container);
            container = NULL;
        }
    }
    
    return container;
}
    

/**
  * @internal
  */
static int
_cache_load(netsnmp_cache * cache, void *vmagic)
{
    netsnmp_container *container;

    DEBUGMSGTL(("internal:cpqSePciFuncTable:_cache_load", "called\n"));

    if ((NULL == cache) || (NULL == cache->magic)) {
        snmp_log(LOG_ERR, "invalid cache for cpqSePciFuncTable_cache_load\n");
        return -1;
    }
    container = (netsnmp_container *) cache->magic;

    /** should only be called for an invalid or expired cache */
    netsnmp_assert((0 == cache->valid) || (1 == cache->expired));

    netsnmp_pcifunc_container_load(container);
    return 0;
}                               /* _cache_load */

/**
 * @Internal
 */
/** remove a row from the table */
static void
cpqSePciFuncTable_freeEntry_cb(netsnmp_pcifunc_entry* entry, void *magic)
{

    cpqSePciFuncTable_freeEntry(entry);
}

/**
  * @internal
  */
static void
_cache_free(netsnmp_cache * cache, void *magic)
{
    netsnmp_container *container;

    DEBUGMSGTL(("internal:cpqSePciFuncTable:_cache_free", "called\n"));

    if ((NULL == cache) || (NULL == cache->magic)) {
        snmp_log(LOG_ERR, "invalid cache in cpqSePciFuncTable_cache_free\n");
        return;
    }
    container = (netsnmp_container *) cache->magic;

    /*
     * empty (but don't free) cache here
     */
    CONTAINER_CLEAR(container,
                    (netsnmp_container_obj_func *)
                    cpqSePciFuncTable_freeEntry_cb, NULL);
}                               /* _cache_free */
    
